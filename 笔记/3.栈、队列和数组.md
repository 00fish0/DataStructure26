## 3.1 栈

1. 定义

    栈(Stack)是只允许在一端插入或删除元素的线性表。

    特点：FILO

    栈顶：允许插入/删除的一端。
    栈底：固定，不允许插入/删除的一端。
    空栈：不包含任何元素的栈。

    n个不同元素进栈/出栈共有$\frac{1}{n+1}C_{2n}^{n}$（卡特兰数）种排列方式。

2. 基本操作

    ```c
    InitStack(&S)   // 初始化栈
    StackEmpty(S)   // 判空
    Push(&S, x)     // 进栈
    Pop(&S, &x)     // 出栈
    GetTop(S, &x)   // 读取栈顶
    DestroyStack(&S)// 销毁栈
    ```

3. 共享栈

    两个栈共享一个一维数组，一个从低地址增长，一个从高地址递减。 此时判空/满为

    1. `top0 = -1` 一号空

        `top1 = MaxSize` 二号空
    
    2. `top1-top0=1` 栈满，即栈顶相邻

4. 链式存储的栈

    第一个元素为栈顶，即等同于在链表上第一个位置进行插入/删除操作。

## 3.2队列

1. 定义

    队列（Queue）只允许在一端进行插入，另一端进行删除的线性表。

    特点：FIFO

    队头：允许删除的一端
    队尾：允许插入的一端
    空队列：不包含任何元素

2. 基本操作

    ```c
    InitQueue(&Q)   // 初始化
    QueueEmpty(Q)   // 判空
    EnQueue(&Q, x)     // 进队
    DeQueue(&Q, &x)     // 出队
    GetHead(Q, &x)   // 读取队头
    ```

3. 顺序存储

    缺点：因为队头和队尾指针不固定，但存储数组是固定的，会导致两个指针不断向数组尾部移动，造成“上溢出”的假象，实际在低地址空间还有存储位置。

4. 循环队列

    每次入队或者出队都取模，使得指针能够回到低地址。

    判空：

    1. 让队尾不要作为存储单元，此时

        `队满`：`(Q.rear+1)%MaxSize == Q.front`
        `队空`：`Q.rear == Q.front`

    2. 增加单独的size变量记录个数
    3. 增加一个tag变量代表是满还是空

        当tag=0，且删除时`Q.rear == Q.front`，则队空。
        当tag=1，且插入时`Q.rear == Q.front`，则队满。

5. 链式存储

    即保存表头和表尾指针。在表尾增加，在表头删除。

6. 双端队列（Deque）

    即两边都可以插入/删除。

## 3.3 栈和队列的应用

1. 栈在括号匹配中的引用

    原理即右括号必须要一个对应的左括号进行匹配。每次遍历左括号则压栈，右括号则取出栈顶并比较。

2. 栈在表达式求值的应用

    正常书写的表达式为中缀表达式，首先转换为后缀表达式。

    转换方式为，对中缀表达式建树，然后按左叶子结点、右叶子结点的顺序递归取出即得后缀表达式。

    对于后缀表达式进行遍历，如果是操作数则压栈，是运算符则取出两个数Y和X，进行`X op Y`运算并压栈，注意，第一次取的作为被操作数。

3. 栈在递归中的应用

    递归模型为：

    1. 递归表达式
    2. 边界出口

    本质就是将大问题分解为**属性相同但规模较小**的问题。

    递归的每一层函数调用/返回本质是一次压栈和出栈。

    递归有栈溢出风险，一般效率并不是太高但简单。

4. 队列在层次遍历中的应用

    要遍历一颗树，要想实现广度优先遍历，即一层一层遍历可以使用队列进行遍历

    1. 根结点入队
    2. 若队空则结束遍历，否则出队并检测是否有左右子结点，如果有则入队。

    这样可以保证每次遍历的都是同一层元素并且将下一层元素全部入队。

5. 队列在计算机系统中的应用

    1. 解决主机与外部设备速度不匹配的问题

        例如缓冲区。

    2. 解决多用户引起的资源竞争问题

        例如OS中的进程调度队列、SPOOLing技术中的等待队列。
