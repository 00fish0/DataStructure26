## 3.1 栈

1. 定义

    栈(Stack)是只允许在一端插入或删除元素的线性表。

    特点：FILO

    栈顶：允许插入/删除的一端。
    栈底：固定，不允许插入/删除的一端。
    空栈：不包含任何元素的栈。

    n个不同元素进栈/出栈共有$\frac{1}{n+1}C_{2n}^{n}$（卡特兰数）种排列方式。

2. 基本操作

    ```c
    InitStack(&S)   // 初始化栈
    StackEmpty(S)   // 判空
    Push(&S, x)     // 进栈
    Pop(&S, &x)     // 出栈
    GetTop(S, &x)   // 读取栈顶
    DestroyStack(&S)// 销毁栈
    ```

3. 共享栈

    两个栈共享一个一维数组，一个从低地址增长，一个从高地址递减。 此时判空/满为

    1. `top0 = -1` 一号空

        `top1 = MaxSize` 二号空
    
    2. `top1-top0=1` 栈满，即栈顶相邻

4. 链式存储的栈

    第一个元素为栈顶，即等同于在链表上第一个位置进行插入/删除操作。

## 3.2队列

1. 定义

    队列（Queue）只允许在一端进行插入，另一端进行删除的线性表。

    特点：FIFO

    队头：允许删除的一端
    队尾：允许插入的一端
    空队列：不包含任何元素

2. 基本操作

    ```c
    InitQueue(&Q)   // 初始化
    QueueEmpty(Q)   // 判空
    EnQueue(&Q, x)     // 进队
    DeQueue(&Q, &x)     // 出队
    GetHead(Q, &x)   // 读取队头
    ```

3. 顺序存储

    缺点：因为队头和队尾指针不固定，但存储数组是固定的，会导致两个指针不断向数组尾部移动，造成“上溢出”的假象，实际在低地址空间还有存储位置。

4. 循环队列

    每次入队或者出队都取模，使得指针能够回到低地址。

    判空：

    1. 让队尾不要作为存储单元，此时

        `队满`：`(Q.rear+1)%MaxSize == Q.front`
        `队空`：`Q.rear == Q.front`

    2. 增加单独的size变量记录个数
    3. 增加一个tag变量代表是满还是空

        当tag=0，且删除时`Q.rear == Q.front`，则队空。
        当tag=1，且插入时`Q.rear == Q.front`，则队满。

5. 链式存储

    即保存表头和表尾指针。在表尾增加，在表头删除。

6. 双端队列（Deque）

    即两边都可以插入/删除。