## 4.1 串

1. 定义

    由零个或多个字符组成的有限序列。

    $$S= 'a_1a_2\dots a_n'$$

    从1开始计数。

    空串：包含0个字符的串。
    子串：任意多个连续的字符组成的子序列。

2. 存储方式

    定长顺序存储；

    堆分配存储；

    快链存储，每一块包含一个后继指针指向下一块。最后一块字符没填满一般用`#`填充。

3. 基本操作

    ```c
    StrAssisn(&T, chars);           // 赋值
    StrCopy(&T, S);                 // 复制
    StrEmpty(S);                    // 判空
    StrCompare(S, T);               // 比较，S>T，返回>0，S<T返回小于0，否则返回0
    StrLength(S);                   // 求长度
    SubString(&Sub, S, pos, len);   // 在S上从pos位置截取len长度子串到Sub中
    ConCat(&T, S1, S2);             // 联接S1,S2到T
    Index(S, T);                    // 在S上查找T，返回起始位数，没有返回0
    ClearString(&S);                // 清空
    DestroyString(&S);              // 销毁
    ```

4. 模式匹配

    `KMP算法`：对于朴素的模式匹配在失败时只向前移动一位，而我们可以发现大部分时候匹配失败时再向前移动一位还是匹配失败，此时则可以向前移动一个更长的位置，具体有多长？则和子串自身有关

    考虑`ababc`这个子串

    假设匹配到`abab`时失败（即第4位b和主串不同），则此时的主串为

    $$
    ...\mathrm{abax}...\\
       \mathrm{abab}
    $$

    此时我们会发现不论x取何值，我们总是应该这样移动子串

    $$
    ...\mathrm{abax}...\\
      \ \ \ \ \ \ \ \ \ \ \ \ \ \mathrm{abab}
    $$

    原因在于如果我们将主串的这一部分单独提取出来会发现是`abax`，而子串的移动长度则取决于这个串的后缀串有多少能和子串的前缀串相同，这里因为`x!=b`，如果没有任何后缀串与子串前缀串相同，故移动整个长度，而如果是

    $$
    ...\mathrm{ababa}...\\
       \mathrm{ababc}
    $$

    此时匹配失败时，则应该移动至

    $$
    ...\mathrm{ababa}...\\
       \ \ \ \ \ \ \ \ \ \mathrm{ababc}
    $$

    这是因为存在一个后缀串`aba`和前缀串`aba`相同。如果按照这样的规则进行匹配则我们会发现不会重复匹配主串中重复的部分，所以时间复杂度为`O(n+m)`。

    那么我们在代码中如何知道每次该移动多长呢，我们又会发现，我们之前提到的 “*我们将主串的这一部分单独提取*” ，这一部分的内容其实就是子串本身，因为它们是已经通过了匹配的部分串，所以我们可以在匹配前先对要匹配的子串自身做处理即可。得到的数据我们称为`next`数组，即下一跳地址。


* **注意事项**：这里全是用位置从1开始，如果表述成下标的话将代码中所有常量-1即可，大家要注意转换关系，例如

    `i=i-j+2;` 变成 `i=i-j+1;`即可。

    而对于`i-T.length`不要变成`i-T.length-1`，只变常量即可。