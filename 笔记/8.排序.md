## 8.1 排序的基本概念

1. 定义

    **排序**：重新排列表中的元素，使表中的元素满足按照关键字有序的过程。
    **稳定性**：若两个元素$R_i$和$R_j$，对应关键字满足$k_i=k_j$，且在排序前$R_i$在$R_j$之前。若使用某种算法排序藕，$R_i$仍在$R_j$之前，则称该算法稳定，否则则是不稳定的。

    **注意**：判别不稳定一般举个反例即可。

    根据数据是否完全在内存中分为

    1. **内部排序**：排序期间元素全部存放在内存中。

        包含插入排序、交换排序、选择排序、归并排序和基数排序。

    2. **外部排序**：排序期间元素无法全部同时存放在内存，在排序中根据要求不断在内、外存之间移动的排序。

    大部分**内部排序**都是基于比较和移动（**基数排序**不基于比较）。
    大部分**内部排序**只适用于顺序存储的线性表。

    基于比较的排序最好时间复杂度为$O(n\log_2n)$，最少比较次数为$\lceil \log_2(n!)\rceil$次。

## 8.2 插入排序

1. 直接插入排序

    即从列表最开始不断维护一个有序序列，直至有序序列长度为n为止。

    1. 初始有序序列长度为0。
    2. 从第1个为止开始，不断插入到有序序列中正确的位置。

    时间复杂度：$O(n^2)$，空间复杂度：$O(1)$。

    最好情况：已经有序，此时时间复杂度$O(n)$，故平均比较次数和移动次数均为$n^2/4$。

    稳点性：每次插入总是从后向前先比较再移动，所以是稳定的。
    适用性：适合顺序存储和链式存储的线性表。

2. 折半插入排序

    利用二分的思维，每次向前找正确的插入位置时使用二分法。

    此时，虽然**比较**的总复杂度为：$O(n\log_2n)$，但移动次数并未改变，所以总时间复杂度依然还是$O(n^2)$。

    同样折半插入依然是一种稳定排序方式。

3. 希尔排序（缩小增量排序）

    上面都是将序列分割为L[0 \~ i-1,i,i+1 ~ n]，即有序序列，比较值，和无须序列，通过不断将比较值插入有序序列进行排序。
    希尔排序将序列分割为L[i, i+d, i+2d,...,i+kd]这样的子序列，然后再对每个子表进行直接插入排序，最后再对全体进行直接插入排序，这样的好处的，每次子序列移动最多只需要$O(k)$，当基本有序后整体只需要移动较少的次数就可以排序完成。

    当n处于某个特定范围时最好复杂度为$O(n^{1.3})$，最坏时间复杂度：$O(n^2)$。
    空间复杂度：$O(1)$

    稳定性：相同关键字可能会被划分到不同子表，所以希尔排序是不稳定的。

    适用性：仅适用于顺序存储的线性表。
