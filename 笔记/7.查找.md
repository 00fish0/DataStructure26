## 7.1 查找的基本概念

1. 查找

    在数据集合中寻找满足某种条件的数据的**过程**。

2. 查找表

    一个预言机，能够满足如下操作

    1. 查询某个特定数据是否在表中
    2. 检索满足条件的数据元素的各种属性
    3. 插入一个元素
    4. 删除一个元素

3. 静态查找表

    若只涉及查找表中1和2操作，则称为静态查找表。

4. 关键字

    唯一标识该元素的某个数据项的值。

5. 平均查找长度

    一次查找的长度是指比较的关键字次数，平均查找长度是指所有查找过程中查找长度的平均值

    $$
    \mathrm{ASL} = \sum_{i=1}^{n}{P_iC_i}
    $$

    $n$为表长，$P_i$为查找第$i$个元素概率，$C_i$为其查找长度，一般都是$P_i=1/n$，即概率相等，此时$\mathrm{ASL} = \frac{\sum_{i=1}^{n}{C_i}}{n}$

## 7.2 顺序查找和折半查找

1. 一般线性表的顺序查找

    从线性表一端开始，逐个检查关键字是否满足条件。

    此时查找第i个元素需要进行$n-i+1$次比较。所以查找成功时，平均查找长度为

    $$
    \mathrm{ASL} = \sum_{i=1}^{n}{P_i(n-i+1)}
    $$

    当概率相等时有$\mathrm{ASL} = (n+1)/2$，而查找不成功需要遍历整个表，即$\mathrm{ASL}_{fail} = n+1$

    **优点**：对数据元素的存储无要求，对有序性也无要求。
    **缺点**：平均查找长度较大，效率低

2. 有序表的顺序查找

    如果存储时是有序的，此时当发现第i个元素小于key，但第i+1个元素大于key时即可返回失败。

    此时我们可以将失败的区间作为一个**失败结点**，链接到第i个结点的左孩子中，下一结点作为右孩子进行连接。此时成功时的平均查找长度不变，而查找不成功的平均查找长度为

    $$
    \mathrm{ASL}_{fail} = \sum_{i=1}^{n}{q_i(l_i-1)} = \frac{1+2+\cdots+n+n}{n+1} = \frac{n}{2}+\frac{n}{n+1}
    $$

    其中$q_i$代表到达第$i$个结点失败的概率，相等查找概率时$q_i=1/(n+1)$，$l_i$代表第i个失败结点所在层数（即位置）。

    **注意**：最后一个结点左右孩子都为失败结点，所以会有两个n。

3. 折半查找（二分）

    适用于有序顺序表。
    就是每次和中间比较，然后可以排除一般，注意比较的时候是大于还是大于等于就行（小于同理），如果带上等于则mid元素不能直接舍弃。

    此时成功时的平均查找长度为

    $$
    \mathrm{ASL} = \frac{1}{n}\sum_{i=1}^{n}{l_i} = \frac{1}{n}(1\times1 + 2\times2 + \cdots + h\times2^{h-1}) \\= \frac{n+1}{n}\log_2{(n+1)}-1\approx \log_2{(n+1)}-1
    $$

    即时间复杂度为$O(log_2n)$，同时查找不成功的平均查找长度即为失败结点的层数之和除以失败结点数。

    **注意**：二分需要随机存取，不适用于链表。

4. 分块查找（索引顺序查找）

    将查找表分为若干块，块内可以无须，快间有序，需保证第i个快最大元素小于第i+1快最小元素。此时将每块最大元素再建立一个索引表。

    查找时先顺序或二分从索引表中找，然后再到具体块内寻找。此时成功时平均查找长度为

    $$
    \mathrm{ASL} = L_I + L_S
    $$

    其中$L_I$代表索引表长度，$L_S$代表每块长度。若将长度为n的顺序表分为b块，每块s个元素，在等概率情况下若采用顺序查找，则平均查找长度为

    $$
    \mathrm{ASL} = L_I + L_S = \frac{b+1}{2} + \frac{s+1}{2} = \frac{s^2+2s+n}{2s}
    $$

    取$s=\sqrt{n}$时，有最小值$\mathrm{ASL}=\sqrt{n}+1$。

## 7.3 树型查找

1. 二叉排序树的定义

    二叉排序树具有如下特征（注意空树也可以算）

    1. 若左子树非空，则左子树上所有结点均小于根结点值。
    2. 若右子树非空，则右子树所有结点均大于根结点值。
    3. 左右子树分别也是一棵二叉排序树。

2. 二叉排序树的查找

    从根结点开始依次比较，小于根结点则递归比较左子树值，大于则递归比较右子树值，直到等于或为空为止。

3. 二叉排序树的插入

    1. 若树为空，则直接插入。
    2. 若小于根结点，则插入左子树，大于则插入右子树。

    插入的结点一定是一个新的叶结点。

4. 二叉排序树的构建

    从空树出发，依次插入元素即可。

5. 二叉排序树的删除

    设删除结点为z。

    1. 若删除叶结点，则可直接删除。
    2. 若z只有左子树或右子树，则让z的子树成为z父结点的子树即可。
    3. 若z包含左右子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树删去这个直接后继（或直接前驱），即转换成前两种情况进行处理。

    **注意**：非叶结点删除后再插入得到的BST和原BST一定不同，叶结点删除后再插入得到的一定相同。

6. BST效率分析

    BST的查找效率取决于树的高度，若左右子树高度差不超过1，则平均查找长度为$O(\log_2n)$，若二叉排序树是只有左右孩子的单支树，则平均查找长度为$O(n)$。

    与直接二分的区别：

    1. 二分判定树唯一，BST和插入顺序有关。
    2. BST插入删除为$O(n)$，而二分插入删除是$O(n)$
    3. 静态查找表适合二分，动态查找表适合BST。

7. 平衡二叉树

8. 红黑树

这一节考的少，后面花时间再看看

## 7.4 B树和B+树

后面再看

## 7.5 散列表

1. 基本概念

    散列函数：关键字映射成对应地址的函数，记为`Hash(key) == Addr`
    散列冲突：多个关键字对应同一地址，因为关键字可能是无限集，所以冲突是不可避免的，但一个好的散列函数应该做到

    1. 尽量减少冲突的可能
    2. 设计好处理冲突的方法

    散列表：存储关键字和地址之间的映射关系。

    从散列表中查询地址时间复杂度为$O(1)$，即与表中元素个数无关。

2. 散列函数构造

    散列函数定义域必须包含全部关键字，值域范围则依赖于散列表的大小或地址范围。
    散列函数计算出的地址应该能够等概率、均匀地分布在整个空间中，从而减少冲突。
    散列函数应该尽可能简单，能够在短时间内计算任意关键字的对应地址。

   1. 直接定址法

       `H(key) = key`或`H(key) = a*key + b`

       即地址和关键字是线性关系，计算简单且不会冲突，适合关键字分布**连续**的情况，否则则会造成空间浪费。

   2. 除留余数法

       设散列表表长$m$，取一个不大于$m$的素数$p$。

       `H(key) = key%p`

       需要选好p使得关键字能够等概率、均匀的分布到空间中。

   3. 数字分析法

       设关键字是$r$进制，选取关键字集合中数码分布较均匀的若干位作为散列地址。
       **注意**：适合已知关键字集合情况，更换关键字后需要重新构造散列函数。

   4. 平方取中法

       取关键字平方值中间几位作为散列地址，具体多少位根据情况而定。
       适用于关键字每位都不均匀或均小于散列地址所需位数。

3. 处理冲突的方法

    用$H_i$表示处理冲突中第$i$次得到的散列地址。

    1. 开放定址法

        $H_i = (H(key) + d_i) \mod m$

        $m$表示表长，$d_i$为增量序列。

        $d_i$常有以下4中取法：

        1. 线性探测法

            $d_i=0,1,2,\cdots,m-1$

            **缺**：可能造成元素堆积，降低查找效率。
        
        2. 平方探测法（二次探测法）

            $d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$，其中$k\le m/2$。

            要求$m=4k+3$且为素数（其实是为了满足二次剩余）。

            **缺**：不能探测所有单元，但能至少探测一半单元。
        
        3. 双散列法

            $d_i=i\times Hash_2(key)$时，利用另一个散列函数计算增量序列。
        
        4. 伪随机序列法

            $d_i$等于伪随机序列。
        
        **注意**：使用开放定址法时不能随便删除元素，因为直接删除会导致本来需要冲突进行二次定位的失去冲突了，导致得到不正确的地址。此时需要删除可以增加一个删除标记进行逻辑删除，但是这也会导致表看起来很满实际很多位置未利用，所以还需要定期维护散列表。

    2. 拉链法（链接法）

        类似邻接表，将冲突的关键字存储到单元的线性链表中。

4. 散列查找及性能分析

    初始化：`Addr=Hash(key)`

    1. 检测表中`Addr`地址是否有记录，无记录返回**失败**，有记录则比较**key**，若相等则返回**成功**，否则说明冲突，执行下一步。
    2. 用给定冲突方式计算下一散列地址，更新Addr值，重新执行步骤1。

    此时平均查找长度

    $$
    ASL = \frac{1}{n}\sum_{i=1}^{n}{第i个key哈希次数}
    $$

    特点：

    1. 虽然散列表记录了映射关系，但由于冲突使得查找仍然需要比较关键字。
    2. 查找效率取决三个因素：散列函数、处理冲突和装填因子

        装填因子：记为$\alpha$，表示表的装满程度

        $$
        \alpha = \frac{表中记录n}{表长度m}
        $$

        即散列表ASL依赖于$\alpha$，而不直接依赖于$n$或$m$。$\alpha$越大，表越满，冲突可能越大。
