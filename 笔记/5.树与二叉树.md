## 5.1 树

1. 定义

    有n个结点的有限集。

    空树：n=0时。

    任意一棵非空树满足：

    1. 有且仅有一个特定的结点：根结点
    2. 当n>1时，其余结点可分为m个互不相交的有限集$T_1,T_2,\cdots,T_m$，其中每个集合本身又是一棵树，称为根的子树。

    显然树是一种递归的数据结构，树作为一种逻辑结构，同时也是一种分层结构，包含两个特点：

    1. 树的根结点没有前驱，除根结点外的所有结点有且仅有一个前驱。
    2. 树中所有结点都可以有零个或多个后继。

2. 基本术语

    1. 关系

        祖先：任意结点K到根结点路径上的结点都为K的祖先，反过来K也是这些结点的子孙。
        双亲：距离K结点最近的祖先即为双亲。根结点是唯一没有双亲的结点。
        兄弟：具有相同双亲的结点。

    2. 度

        度：一个结点孩子（后继）的数量，同时结点最大度数为树的度。
        分支结点：度大于0的结点。
        叶结点：度等于0的结点。

    3. 层次
        层次：根结点为第1层，它的子结点为第2层，依此类推。双亲在同一层的结点为**堂兄弟**。
        深度：从根结点开始自顶向下逐层累加。
        高度：从叶结点开始自底向上逐层累加。
        树的高度或深度为最大层数。
    4. 有序
        树中结点的各子树从左到右有次序不能互换的为**有序树**，否则为**无序树**。

    5. 路径

        树中两个结点的路径是这两个结点直接所经过的结点序列构成的，**路径长度**是路径上所经过的**边**的个数。

    6. 森林

        森林是m棵互不相交的树的集合。

3. 性质

    1. 树中结点数等于所有结点的度数之和+1。

        树的总结点数还等于总分支数+1，总分支数为度数结点数量*度数

        $$
        n = \sum_{i=1}^{m}{i\cdot n_i}+1 = \sum_{i=0}^{m}{n_i}
        $$

    2. 度为m的树中第i层上之多有$m^{i-1}$个结点。
    3. 高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点。

        $$
        S = 1 + m + m^2 + \cdots + m^{h-1} = \frac{m^h-1}{m-1}
        $$

    4. 具有n个结点的m叉树的最小高度为$\lceil\log_m{(n(m-1)+1)}\rceil$

        即
        $$
        n = 1 + m + \cdots + m^{x-1} = \frac{m^{x}-1}{m-1}
        $$

        有$x = \lceil\log_m{(n(m-1)+1)}\rceil$

## 5.2 二叉树

1. 定义

    每个结点至多包含两棵子树，且子树有左右之分，次序不能任意颠倒。

    空二叉树：n=0

    与度为2的有序树的区别：

    1. 度为2的树至少有3个结点，而二叉树可以为空
    2. 度为2的有序树的孩子的左右次序是相对于另一孩子而言，若某个结点只有一个孩子则这个孩子无须区分左右，而二叉树无论其孩子数是否为2，均需确定左右次序。

2. 特殊二叉树

    1. 满二叉树

        一棵高度为h，且含$2^{h-1}$个结点的二叉树称为满二叉树，即满中的每层都含有最多的结点。满二叉树的叶结点都集中在最下一层。

        若自上而下、自左向右进行排序，则对于i号结点，其双亲为$\lfloor i/2\rfloor$，左孩子（若存在）为$2i$，右孩子为$2i+1$。

    2. 完全二叉树

        高度为$h$，有$n$个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树编号为1~n的结点一一对应时称为**完全二叉树**。

        1. 若$i\le \lfloor n/2\rfloor$，则结点i为分支结点，否则为叶结点。
        2. 叶结点只可能在层次最大的两层上出现，且最大层上的叶结点都依次排列在该层最左边位置。
        3. 若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子。
        4. 若i号结点为叶节点或只有左孩子，则编号大于i的结点均为叶结点。
        5. 若n为奇数，则每个分支结点都有左右孩子，n为偶数则编号最大的分支结点(编号为$n/2$)只有左孩子。

    3. 二叉排序树

        左子树上所有结点的关键字均小于根结点关键字，右子树所有结点的关键字均大于根结点关键字，同时左右子树又各是一棵二叉排序树。

    4. 平衡二叉树

        树上任意一个结点的左子树和右子树的深度之差不超过1。

3. 性质

    1. 非空二叉树上的叶结点数等于度为2的结点数加1。

        设总数为$n$，度代表的结点数为$n_0,n_1,n_2$，则有$n = n_0+n_1+n_2$，同时根结点外其他结点都有一个分支进入，设B为总分支数，则有$n = B + 1$。由于分支是由度为1或2的结点射出，又有$B = n_1+2n_2$，即得$n_0=n_2+1$。

    2. 非空二叉树上第k层上至多有$2^{k-1}$个结点。
    3. 高度为h的二叉树至多有$2^h-1$个结点。
    4. 完全二叉树从上至下、从左至右编号则有

        1. 当$i>1$式，结点i的双亲的编号为$\lfloor i/2\rfloor$。
        2. 结点i的左孩子（如存在）为$2i$，右孩子（如存在）为$2i+1$。
        3. 结点$i$所在层次（深度）为$\lfloor\log_2{i}\rfloor+1$。
    5. 具有n个结点的完全二叉树高度为$\lceil\log_2{(n+1)}\rceil$或$\lfloor\log_2{n}\rfloor+1$。

4. 存储结构

    1. 顺序存储

        即将编号i的存入数组i号，用0表示不存在的空结点。（一般从1开始存储，方便计算性质）

    2. 链式存储

        用`lchild,data,rchild`存储左孩子、数据和右孩子。

## 5.3 二叉树遍历

和之前的中序、后序表达式转换类似。

1. 先序遍历

    1. 访问根结点
    2. 先序遍历左子树
    3. 先序遍历右子树

2. 中序遍历

    1. 中序遍历左子树
    2. 访问根结点
    3. 中序遍历右子树

3. 后序遍历

    1. 后序遍历左子树
    2. 后序遍历右子树
    3. 访问根结点

4. 递归算法和非递归算法的转换

    可以借助栈来实现非递归遍历函数。

5. 层次遍历

    借助队列实现层次遍历。

6. 由遍历序列构造二叉树

    由二叉树的先序序列和中序序列可以唯一确定一棵二叉树

    先序序列：`ABCDEFGHI`
    中序序列：`BCAEDGHFI`

    因为先序是根左右，所以A一定是一个包含子树的结点，由因为中序是左右根，所以A在中序的位置的两次就分别是A的左右子树，即

    ```txt
       A
    BC   DEFGHI
    ```

    同理对于左子树，B也是一个根，而B左子树为空故只包含右子树，同理D也是一个根，左子树为E，右子树为FGHI

    ```txt
            A
    B               D
        C       E       FGHI
    ```

    同理可得树为

    ```txt
            A
      B            D
        C      E      F
                   G    I
                     H
    ```

## 5.3.2 线索二叉树

1. 概念

    遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列。传统的二叉链表存储仅能提现父子关系，不能直接得到前驱或后继。而其实一个包含n个结点得树有n+1个空指针，此时若使用这些空指针保存前驱或者后继则可以像遍历单链表一样遍历二叉树。

    规定：若无左子树，令`lchild`指向前驱，若无右子树，令`rchild`指向后继。此时还需增加两个标志域标识指针域，以指向左孩子或前驱。

    `lchild|ltag|data|rtag|rchild`

    `ltag`为1代表指向`lchild`前驱，否则代表指向左孩子，同理`rtag`为1代表`rchild`指向后继，否则为右孩子。

    **解题**：判断是否线索二叉树只需要关注其左线索是否为前驱，右线索是否为后继，对不上则不是线索树，无须关系是何种顺序。

2. 线索化

    线索化即将二叉树中得空指针改为指向前驱或后继的线索，而前驱或后续需要在遍历中得到，因此线索化的本质就是遍历一次二叉树。

    以中序为例，每次便是

    1. 递归线索化左子树
    2. 若根结点左子树不存在，则赋值为前驱，若前驱的右子树不存在，则赋值为当前根结点（上一结点的后继）
    3. 改变上一结点为当前结点
    4. 递归线索化右子树

    当完全上述步骤后还需要对最后的结点的右子树赋值为NULL。

    为了方便也可以在二叉树的线索链表上添加一个头结点，令第一个结点的前驱为头结点，最后一个结点的后继为头结点。
    同时让头结点的`lchild`指向根结点，`rchild`指向最后一个结点，这样就可以完成双向遍历了。

3. 遍历

    1. 找到整个树的初始结点，从根开始往左子树遍历。
    2. 若非空，则访问当前结点
    3. 访问下一结点。若右子树为空，则`rchild`就指向后继，若右子树不为空，则按照步骤1找到右子树的初始结点即为当前结点后继。

4. 先序线索和后序线索

    和中序线索类似，详情见代码。

## 5.4 树和森林

1. 树的存储结构

    1. 双亲表示法

        用一维连续空间存储每个结点。同时每个结点中增设一个伪指针指示双亲结点的位置。

    2. 孩子表示法

        将孩子用单链表链接起来形成一个线性结构。n个结点就有n个孩子链表。找双亲需要遍历n个结点的n个链表。

    3. 孩子兄弟表示法

        也叫**二叉树表示法**，每个结点包含结点值、结点指向的第一个孩子指针、下一个兄弟结点指针。

2. 树、森林与二叉树的转换

    树->二叉树：给定一棵树，可以找到唯一对应的一棵二叉树。规则为：

    1. 每个结点的左指针指向第一个孩子
    2. 右指针指向相邻的右兄弟

    简称**左孩子右兄弟**，即可完成树->二叉树的转换。

    森林->二叉树：

    1. 将每个树转换为对应的二叉树
    2. 将每棵树的根视为兄弟，第一颗树根结点作为最终的根结点建树。

3. 树和森林的遍历

    1. 先根遍历

        1. 若树非空，访问根结点。
        2. 再根据先序遍历子树

    2. 后根遍历

        1. 依次遍历所有子树，再访问根结点（后序遍历）

    3. 先序遍历森林

        1. 若非空则访问第一棵树的根结点
        2. 先序遍历第一棵树根结点的子树森林
        3. 先序遍历其他树

    4. 中序遍历森林

        1. 中序遍历第一棵树根结点的子树森林
        2. 访问第一棵树的根结点
        3. 中序遍历其他树

    |树|森林|二叉树|
    |-|-|-|
    |先根遍历|先序遍历|先序遍历|
    |后根遍历|中序遍历|中序遍历|

## 5.5 树与二叉树的应用

1. 哈夫曼树定义

    结点带权值的树。

    从树的根到任意结点的路径长度（经过的边数）与该结点的权值的乘积，称为该结点的**带权路径长度**，所有**叶结点**的带权路径长度之和为该**树的带权路径长度**。

    $$
    \mathrm{WPL} = \sum_{i=1}^{n}{w_il_i}
    $$

    其中$w_i$为第$i$个结点权值，$l_i$为该结点到根结点的路径长度。

2. 哈夫曼树构造

    给定$n$个权值分别为$w_1,w_2,\dots,w_n$的结点，构造过程如下

    1. 将$n$个结点分别作为$n$棵仅含一个结点的二叉树，构成森林$F$。
    2. 构造一个新结点，从$F$中选两棵根结点权值最小的树作为新结点的左右子树，并将新结点的权值设置为左、右子树上根结点之和。
    3. 从$F$删除两棵树，并将新的树添加到$F$。
    4. 重复2，3直至只剩一棵树。

    构造过程包含如下特点：

    1. 每个初始结点最终都成为叶结点，权值越小的结点到根结点的路径长度越大。
    2. 构造中新建了$n-1$个结点。因此总结点数为$2n-1$。
    3. 每次构造都选择2棵树作为新节点孩子，因此哈夫曼树不存在度为1的结点。

3. 哈夫曼编码

    通信中，若对每个字符等长编码则称为**固定长度编码**。
    变长编码称为**可变长度编码**，其特点是频率高的字符赋以短编码（例如摩斯）。

    若没有一个编码是另一个编码的前缀，则称为**前缀编码**（即无须分隔符，不会歧义）。

    此时我们将每个字符作为一个独立结点，权值为其出现的频度（次数），构造出哈夫曼树，此时根结点到每个结点的路径编码（例如左子树代表0，右子树代表1）即为一种**可变长度前缀编码**。

    此时这棵哈夫曼树的WPL也为二进制编码的长度。

    **注意**：如果存在相同的权值，构造出的哈夫曼树可能不同，但WPL一定相同。

4. 并查集

    一种能够方便管理元素所属集合的数据结构。

    ```cpp
    Initial(S)          // 初始化，每个结点都作为一个集合
    Union(S, R1, R2)    // 把集合中子集R2并入R1，要求R1和R2不相交
    Find(S, x)          // 查找元素x所在子集合，返回子集合根结点
    ```

    用树可以很方便的完成上述操作，详情看代码